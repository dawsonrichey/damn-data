<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Task Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .kanban-column {
            min-height: 300px;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            transition: background-color 0.2s ease-in-out;
        }
        .kanban-column.drag-over {
            background-color: #d1d5db;
        }
        .task-card {
            background-color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            margin-bottom: 0.75rem;
            cursor: grab;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: box-shadow 0.2s ease-in-out, opacity 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
         .task-description {
            word-break: break-word;
         }
        .task-card:active {
            cursor: grabbing;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .task-card.dragging {
            opacity: 0.5;
        }
        .task-hidden {
            display: none !important;
        }
        .drop-placeholder {
            background-color: #9ca3af;
            min-height: 50px;
            border-radius: 0.375rem;
            margin-bottom: 0.75rem;
            opacity: 0.5;
        }
        #confetti-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;
        }
        #importFile { display: none; }
        .tags-container { display: flex; flex-wrap: wrap; gap: 0.375rem; margin-top: 0.5rem; }
        .tag-badge {
            background-color: #dbeafe; color: #1e40af; padding: 0.125rem 0.5rem; border-radius: 9999px;
            font-size: 0.75rem; font-weight: 500; white-space: nowrap;
        }
        /* Chart container */
        #storageChartContainer {
            max-width: 250px; /* Limit chart size */
            margin: 1rem auto 0; /* Center chart below buttons */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">Kanban Task Tracker</h1>

        <div class="mb-8 p-4 bg-white rounded-lg shadow space-y-4">
            <div>
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Add New Task</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-3">
                    <input type="text" id="newTaskInput" placeholder="Enter task description..." class="p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="text" id="newTaskTags" placeholder="Tags (comma-separated)..." class="p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                 <button id="addTaskBtn" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">
                    Add Task
                </button>
            </div>

            <div class="border-t pt-4 space-y-3">
                 <div>
                    <label for="filterTagInput" class="block text-sm font-medium text-gray-700 mb-1">Filter by Tag:</label>
                    <input type="text" id="filterTagInput" placeholder="Enter tag to filter..." class="w-full sm:w-1/2 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                 <div class="space-y-3 sm:space-y-0 sm:flex sm:flex-wrap sm:gap-3">
                     <button id="exportTasksBtn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">
                        Download Tasks (JSON)
                    </button>
                     <button id="importTasksBtn" class="w-full sm:w-auto bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">
                        Upload Tasks (JSON)
                    </button>
                     <input type="file" id="importFile" accept=".json">
                     <button id="clearStorageBtn" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out sm:ml-auto">
                        Clear All Tasks
                    </button>
                </div>
                 <div id="storageChartContainer">
                     <h3 class="text-center text-sm font-medium text-gray-600 mb-2">Estimated Local Storage Usage (5MB Limit)</h3>
                     <canvas id="storageUsageChart"></canvas>
                 </div>
            </div>
             <div id="messageArea" class="text-sm text-gray-600 min-h-[1.25rem]"></div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div id="todo" class="kanban-column" data-column-id="todo">
                <h2 class="text-lg font-semibold mb-4 text-center text-gray-700 border-b pb-2 border-gray-400">To Do</h2>
                <div class="tasks-container space-y-3"></div>
            </div>
            <div id="inprogress" class="kanban-column" data-column-id="inprogress">
                <h2 class="text-lg font-semibold mb-4 text-center text-gray-700 border-b pb-2 border-gray-400">In Progress</h2>
                <div class="tasks-container space-y-3"></div>
            </div>
            <div id="done" class="kanban-column" data-column-id="done">
                <h2 class="text-lg font-semibold mb-4 text-center text-gray-700 border-b pb-2 border-gray-400">Done</h2>
                <div class="tasks-container space-y-3"></div>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <script>
        // --- DOM Elements ---
        const columns = document.querySelectorAll('.kanban-column');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const newTaskInput = document.getElementById('newTaskInput');
        const newTaskTagsInput = document.getElementById('newTaskTags');
        const clearStorageBtn = document.getElementById('clearStorageBtn');
        const exportTasksBtn = document.getElementById('exportTasksBtn');
        const importTasksBtn = document.getElementById('importTasksBtn');
        const importFileInput = document.getElementById('importFile');
        const messageArea = document.getElementById('messageArea');
        const filterTagInput = document.getElementById('filterTagInput');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const storageChartCanvas = document.getElementById('storageUsageChart'); // Chart canvas
        const STORAGE_KEY = 'kanbanTasks';
        const LOCAL_STORAGE_LIMIT_BYTES = 5 * 1024 * 1024; // Estimate 5MB limit

        // --- Chart Instance ---
        let storageChart = null; // To hold the Chart.js instance

        // --- Confetti Instance ---
        const myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });

        // --- Task Counter ---
        let taskCounter = 1;

        // --- Utility Functions ---
        function showMessage(msg, isError = false) {
            messageArea.textContent = msg;
            messageArea.className = `text-sm min-h-[1.25rem] ${isError ? 'text-red-600' : 'text-green-600'}`;
            setTimeout(() => {
                if (messageArea.textContent === msg) {
                   messageArea.textContent = '';
                   messageArea.className = 'text-sm text-gray-600 min-h-[1.25rem]';
                }
            }, 5000);
        }

        /** Formats bytes into KB or MB */
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- Filtering Function ---
        function filterTasksByTag() {
            const filterTag = filterTagInput.value.trim().toLowerCase();
            const allTaskCards = document.querySelectorAll('.task-card');
            allTaskCards.forEach(card => {
                let hasTag = false;
                if (!filterTag) { hasTag = true; }
                else {
                    const tagBadges = card.querySelectorAll('.tag-badge');
                    tagBadges.forEach(badge => {
                        if (badge.textContent.toLowerCase().includes(filterTag)) hasTag = true;
                    });
                }
                card.classList.toggle('task-hidden', !hasTag);
            });
        }

        // --- Chart Functions ---

        /** Calculates estimated localStorage usage */
        function calculateLocalStorageUsage() {
            const savedDataString = localStorage.getItem(STORAGE_KEY);
            let usedBytes = 0;
            if (savedDataString) {
                // Estimate byte size using Blob
                usedBytes = new Blob([savedDataString]).size;
            }
            const remainingBytes = Math.max(0, LOCAL_STORAGE_LIMIT_BYTES - usedBytes); // Ensure non-negative
            return { usedBytes, remainingBytes };
        }

        /** Initializes or updates the storage usage pie chart */
        function updateStorageChart() {
            if (!storageChartCanvas) return; // Don't proceed if canvas doesn't exist
            const ctx = storageChartCanvas.getContext('2d');
            const { usedBytes, remainingBytes } = calculateLocalStorageUsage();

            const chartData = {
                labels: [
                    `Used: ${formatBytes(usedBytes)}`,
                    `Est. Remaining: ${formatBytes(remainingBytes)}`
                ],
                datasets: [{
                    label: 'LocalStorage Usage',
                    data: [usedBytes, remainingBytes],
                    backgroundColor: [
                        'rgb(239, 68, 68)', // Red-500 for used
                        'rgb(34, 197, 94)'  // Green-500 for remaining
                    ],
                    hoverOffset: 4
                }]
            };

            if (storageChart) {
                // Update existing chart
                storageChart.data = chartData;
                storageChart.update();
            } else {
                // Create new chart
                storageChart = new Chart(ctx, {
                    type: 'pie',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: true, // Keep aspect ratio
                        plugins: {
                            legend: {
                                position: 'bottom', // Position legend below
                                labels: {
                                    boxWidth: 12, // Smaller color boxes
                                    font: { size: 10 } // Smaller font
                                }
                            },
                            tooltip: {
                                // Optional: customize tooltips if needed
                                callbacks: {
                                     label: function(context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed !== null) {
                                            label += formatBytes(context.parsed);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }


        // --- LocalStorage & Data Functions ---

        /** Gets the current task data from the board state, including tags. */
        function getCurrentTasksData() {
             const tasksData = { todo: [], inprogress: [], done: [] };
             let maxIdNum = 0;
             columns.forEach(column => {
                const columnId = column.dataset.columnId;
                const tasksContainer = column.querySelector('.tasks-container');
                const taskCards = tasksContainer.querySelectorAll('.task-card');
                taskCards.forEach(card => {
                    const taskId = card.dataset.taskId;
                    const descriptionElement = card.querySelector('.task-description');
                    const tagsContainer = card.querySelector('.tags-container');
                    const taskText = descriptionElement ? descriptionElement.textContent : '';
                    let tags = [];
                    if (tagsContainer) {
                        tags = Array.from(tagsContainer.querySelectorAll('.tag-badge')).map(badge => badge.textContent);
                    }
                    tasksData[columnId].push({ id: taskId, text: taskText, tags: tags });
                    const idNum = parseInt(taskId.split('-')[1]);
                    if (!isNaN(idNum) && idNum > maxIdNum) maxIdNum = idNum;
                });
             });
             tasksData.nextTaskId = maxIdNum + 1;
             return tasksData;
        }

        /** Saves the current state of tasks in all columns to localStorage. */
        function saveTasksToLocalStorage() {
            const tasksData = getCurrentTasksData();
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(tasksData));
                updateStorageChart(); // Update chart after saving
            } catch (error) {
                console.error("Error saving tasks to localStorage:", error);
                showMessage("Could not save tasks. Storage might be full or disabled.", true);
            }
        }

        /** Loads tasks from localStorage and populates the columns. */
        function loadTasksFromLocalStorage() {
            const savedData = localStorage.getItem(STORAGE_KEY);
            clearBoardUI();

            if (!savedData) {
                console.log("No saved tasks found.");
                taskCounter = 1;
            } else {
                try {
                    const tasksData = JSON.parse(savedData);
                    if (typeof tasksData !== 'object' || tasksData === null || !Array.isArray(tasksData.todo) || !Array.isArray(tasksData.inprogress) || !Array.isArray(tasksData.done)) {
                        throw new Error("Invalid data structure in localStorage.");
                    }
                    Object.keys(tasksData).forEach(columnId => {
                        if (columnId === 'nextTaskId') return;
                        const columnElement = document.getElementById(columnId);
                        if (columnElement && Array.isArray(tasksData[columnId])) {
                            const tasksContainer = columnElement.querySelector('.tasks-container');
                            tasksData[columnId].forEach(task => {
                                if (task && typeof task.id === 'string' && typeof task.text === 'string' && Array.isArray(task.tags)) {
                                    const taskCard = createTaskCard(task.text, task.id, task.tags);
                                    tasksContainer.appendChild(taskCard);
                                } else { console.warn("Skipping invalid task object:", task); }
                            });
                        } else if(columnElement) { console.warn(`Expected array for column ${columnId}, but found:`, tasksData[columnId]); }
                    });
                    taskCounter = parseInt(tasksData.nextTaskId) || 1;
                    if (taskCounter < 1) taskCounter = 1;
                } catch (error) {
                    console.error("Error loading or parsing tasks from localStorage:", error);
                    showMessage("Could not load saved tasks. Data might be corrupted. Clearing storage.", true);
                    localStorage.removeItem(STORAGE_KEY);
                    taskCounter = 1;
                    clearBoardUI();
                }
            }
             // Update chart and apply filter regardless of whether data was loaded
            updateStorageChart();
            filterTasksByTag();
        }

        /** Clears all tasks from the board UI. */
        function clearBoardUI() {
             columns.forEach(column => {
                column.querySelector('.tasks-container').innerHTML = '';
            });
        }

        /** Handles the click event for the clear storage button. */
        function handleClearStorage() {
            if (confirm("Are you sure you want to delete ALL tasks? This action cannot be undone.")) {
                try {
                    localStorage.removeItem(STORAGE_KEY);
                    clearBoardUI();
                    taskCounter = 1;
                    filterTagInput.value = '';
                    filterTasksByTag();
                    updateStorageChart(); // Update chart after clearing
                    showMessage("All tasks cleared successfully.");
                    console.log("Tasks cleared from localStorage and board.");
                } catch (error) {
                    console.error("Error clearing tasks from localStorage:", error);
                    showMessage("Could not clear tasks. Please check browser permissions.", true);
                }
            } else { console.log("Clear storage cancelled by user."); }
        }

        // --- Import/Export Functions ---

        /** Handles exporting tasks to a JSON file. */
        function handleExportTasks() {
            try {
                const tasksData = getCurrentTasksData();
                const jsonString = JSON.stringify(tasksData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'kanban-tasks.json';
                document.body.appendChild(a); a.click();
                document.body.removeChild(a); URL.revokeObjectURL(url);
                showMessage("Tasks exported successfully.");
            } catch (error) {
                console.error("Error exporting tasks:", error);
                showMessage("Failed to export tasks.", true);
            }
        }

        /** Handles the file selection for import. */
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/json') {
                 showMessage(`Invalid file type: ${file.type}. Please upload a .json file.`, true);
                 event.target.value = null; return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    const importedData = JSON.parse(fileContent);
                    // Validation... (same as before)
                    if (typeof importedData !== 'object' || importedData === null || !Array.isArray(importedData.todo) || !Array.isArray(importedData.inprogress) || !Array.isArray(importedData.done) || typeof importedData.nextTaskId !== 'number' || importedData.nextTaskId < 1) { throw new Error("Invalid JSON structure for Kanban tasks."); }
                    const allTasksValid = ['todo', 'inprogress', 'done'].every(col => importedData[col].every(task => task && typeof task.id === 'string' && typeof task.text === 'string' && Array.isArray(task.tags)));
                    if (!allTasksValid) { throw new Error("Invalid task format within the JSON file."); }

                    // If validation passes:
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(importedData));
                    loadTasksFromLocalStorage(); // Reload board (this will also update chart and apply filter)
                    showMessage("Tasks imported successfully!");
                } catch (error) {
                    console.error("Error processing imported file:", error);
                    showMessage(`Failed to import tasks: ${error.message}`, true);
                } finally { event.target.value = null; }
            };
            reader.onerror = function(e) {
                console.error("Error reading file:", e);
                showMessage("Error reading the selected file.", true);
                event.target.value = null;
            };
            reader.readAsText(file);
        }

        // --- Core Task Functions ---

        /** Creates a new task card element, including tags. */
        function createTaskCard(text, id, tags = []) {
            const card = document.createElement('div');
            card.className = 'task-card';
            card.setAttribute('draggable', 'true'); card.setAttribute('data-task-id', id);
            const description = document.createElement('div');
            description.className = 'task-description'; description.textContent = text;
            card.appendChild(description);
            if (tags && tags.length > 0) {
                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'tags-container';
                tags.forEach(tagText => {
                    if (tagText.trim()) {
                        const tagBadge = document.createElement('span');
                        tagBadge.className = 'tag-badge'; tagBadge.textContent = tagText.trim();
                        tagsContainer.appendChild(tagBadge);
                    }
                });
                if (tagsContainer.hasChildNodes()) card.appendChild(tagsContainer);
            }
            card.addEventListener('dragstart', handleDragStart); card.addEventListener('dragend', handleDragEnd);
            return card;
        }

        /** Adds a new task to the 'To Do' column and saves state. */
        function addTask() {
            const taskText = newTaskInput.value.trim();
            const tagsText = newTaskTagsInput.value.trim();
            if (taskText === '') { showMessage('Task description cannot be empty.', true); return; }
            const tags = tagsText.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
            const taskId = `task-${taskCounter++}`;
            const newTaskCard = createTaskCard(taskText, taskId, tags);
            document.querySelector('#todo .tasks-container').appendChild(newTaskCard);
            newTaskInput.value = ''; newTaskTagsInput.value = '';
            saveTasksToLocalStorage(); // This now also updates the chart
            filterTasksByTag();
            showMessage('Task added.');
        }

        /** Triggers the confetti animation. */
        function triggerConfetti() { myConfetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } }); }

        // --- Drag and Drop Event Handlers ---
        let draggedItem = null; let placeholder = null;
        function createPlaceholder() { const ph = document.createElement('div'); ph.className = 'drop-placeholder'; return ph; }
        function handleDragStart(event) {
            if (!event.target.classList.contains('task-card') || event.target.classList.contains('task-hidden')) { event.preventDefault(); return; }
            draggedItem = event.target;
            event.dataTransfer.setData('text/plain', draggedItem.dataset.taskId); event.dataTransfer.effectAllowed = 'move';
            setTimeout(() => { if(draggedItem) draggedItem.classList.add('dragging'); }, 0);
            placeholder = createPlaceholder(); placeholder.style.height = `${draggedItem.offsetHeight}px`;
        }
        function handleDragEnd(event) {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                saveTasksToLocalStorage(); // Save final state (also updates chart)
            }
            if (placeholder && placeholder.parentNode) { placeholder.parentNode.removeChild(placeholder); }
            draggedItem = null; placeholder = null;
            columns.forEach(col => col.classList.remove('drag-over'));
        }
        function handleDragOver(event) {
            event.preventDefault();
            const column = event.target.closest('.kanban-column');
            if (!column || !placeholder || !draggedItem) return;
            if (!column.classList.contains('drag-over')) { columns.forEach(col => col.classList.remove('drag-over')); column.classList.add('drag-over'); }
            const tasksContainer = column.querySelector('.tasks-container');
            const mouseY = event.clientY;
            const cards = [...tasksContainer.querySelectorAll('.task-card:not(.dragging):not(.task-hidden)')];
            let nextElement = null;
            for (const card of cards) { const rect = card.getBoundingClientRect(); if (mouseY < rect.top + rect.height / 2) { nextElement = card; break; } }
            if (nextElement) { tasksContainer.insertBefore(placeholder, nextElement); } else { tasksContainer.appendChild(placeholder); }
        }
        function handleDragLeave(event) {
            const column = event.target.closest('.kanban-column');
            if (column && !column.contains(event.relatedTarget) && event.relatedTarget !== placeholder) { column.classList.remove('drag-over'); }
            if (!event.relatedTarget && placeholder && placeholder.parentNode) { placeholder.parentNode.removeChild(placeholder); }
        }
        function handleDrop(event) {
            event.preventDefault();
            const column = event.target.closest('.kanban-column');
            if (!column || !draggedItem) return;
            const tasksContainer = column.querySelector('.tasks-container');
            if (placeholder && placeholder.parentNode === tasksContainer) { tasksContainer.replaceChild(draggedItem, placeholder); }
            else { tasksContainer.appendChild(draggedItem); if (placeholder && placeholder.parentNode) { placeholder.parentNode.removeChild(placeholder); } }
            draggedItem.classList.remove('task-hidden');
            if (column.id === 'done') { triggerConfetti(); }
            placeholder = null; column.classList.remove('drag-over');
            // Save is handled in handleDragEnd
        }

        // --- Event Listeners ---
        addTaskBtn.addEventListener('click', addTask);
        newTaskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        newTaskTagsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        clearStorageBtn.addEventListener('click', handleClearStorage);
        exportTasksBtn.addEventListener('click', handleExportTasks);
        importTasksBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', handleFileImport);
        filterTagInput.addEventListener('input', filterTasksByTag); // Filter listener
        columns.forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('dragleave', handleDragLeave);
            column.addEventListener('drop', handleDrop);
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromLocalStorage(); // Load tasks first
            // updateStorageChart(); // Initial chart draw - Now called within loadTasksFromLocalStorage
        });

    </script>

</body>
</html>
